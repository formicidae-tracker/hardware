.define public CYCLE 32         ; must be even
.define public READOUT 24       ; must be <= CYCLE - 5
.define SCAN_LENGTH (CYCLE - 6) / 2
.define public IRQ_SAMPLE_SIGNAL 0
.define public IRQ_TX_FAILURE_SIGNAL 1
.define public IRQ_SIGNAL_SOF 2
.define public IRQ_SIGNAL_EOF 3

.define public CANBUS_CLOCK_SM   0
.define public CANBUS_RX_SM      1
.define public CANBUS_ACK_SM     2
.define public CANBUS_TX_SM      3

;;; Re-Synchronize the clock from the RX signal and emit sample signal
;;; Instruction: 13
;;; Emit SOF and EOF IRQ for the CPU synchronization
;;; Emit SAMPLE only for other state machine in the PIO
.program canbus_clock
.origin 0
reset:
	SET y, 9                ;
	IRQ set IRQ_SIGNAL_EOF  ;
wait_dominant:
	JMP pin wait_dominant                   ; CP: 0
	IRQ set IRQ_SIGNAL_SOF    [READOUT - 5] ; CP: 1 --> READOUT - 4
	;; we need that READOUT + 2*X + 4 = CYCLE + READOUT - 2
	;; <=>  X = (CYCLE - 6) / 2
	SET x, SCAN_LENGTH                      ; CP: READOUT - 3
send_sample_signal:
	IRQ set IRQ_SAMPLE_SIGNAL               ; CP: READOUT - 2, READOUT + 2*X + 4
	JMP pin scan_recessive                  ; CP: READOUT - 1
	JMP send_sample_signal      [CYCLE - 3] ; CP: READOUT --> READOUT + CYCLE -1
scan_recessive:
	JMP x-- test_resynchronization          ; CP: READOUT, READOUT + 2, ...
	;; Scan completed, we must sample from our clock
	JMP y-- reset                           ; CP: READOUT + 2*X + 1
	;; Not 10 recessive bit, so not at EOF, we sample
	JMP send_sample_signal              [1] ; CP: READOUT + 2*X + 2 --> READOUT + 2*X + 3
test_resynchronization:
	JMP pin scan_recessive                  ; CP: READOUT + 1, READOUT + 3, ...
	;; Last saw an edge, it is a resynchronization condition and becomes CP: 0,
	;; next is CP:1
	JMP send_sample_signal    [READOUT - 4] ; CP: 1 --> READOUT - 3


.program canbus_rx_and_ack
.origin 13
.in 32 left
.out 32 right
rx_wait_sample:
	WAIT 1 irq IRQ_SAMPLE_SIGNAL               ; CP: READOUT - 1
	IN pins, 1                                 ; CP: READOUT
public rx_only_end:
	;; load counter in ISR
	IN y, 11                                   ; CP: READOUT + 1
	MOV y, isr                                 ; CP: READOUT`+ 2
	JMP y-- compare                            ; CP: READOUT + 3
compare:
	JMP x!=y load_next   [CYCLE - READOUT - 5] ; CP: READOUT + 4 - CYCLE - 1
	SET pins, 0                                ; CP: 0
load_next:
	MOV osr, y   ; CP: 0,1
	;; discard 12 bit shifting right, we got only the 20 LSB
	OUT null, 12                               ; CP: 1,2
	;; pulling this 20 LSB into ISR, shifting left
	IN osr, 20                                 ; CP: 2,3
	PULL noblock                               ; CP: 3,4
	MOV x, osr                                 ; CP: 4,5


;;; This program transmit its FIFO to bus and test for collision.
;;; In case of collision, indefinetly loops doing nothing to not held the bus
;;; Instruction: 6

.program canbus_tx
.origin 26
.out 1 left auto 32
pull_bit:
	OUT x, 1                            [1] ; CP: CYCLE - 2 --> CYCLE - 1
.wrap_target
write:
	MOV pins, x               [READOUT - 1] ; CP: 0 --> READOUT - 1
	JMP pin pull_bit   [CYCLE - READOUT -3] ; CP: READOUT --> CYCLE - 3
	JMP x-- conflict                        ; CP: CYCLE - 2
	OUT x, 1                                ; CP: CYCLE - 1
.wrap
	; we jumped here from from a state where we set pin to recessive and readout
	; a dominant, we should indefinetly stay in that state, the CPU must catch
	; the condition and reset the program.
conflict:
	JMP  conflict

% c-sdk {

#include <hardware/platform_defs.h>
#include <pico/error.h>


static inline int canbus_clock_program_init(PIO pio, uint offset, uint rx_pin, float freq) {
	pio_sm_claim( pio, CANBUS_CLOCK_SM );

	pio_gpio_init( pio, rx_pin );

	int err = pio_sm_set_consecutive_pindirs( pio, CANBUS_CLOCK_SM ,rx_pin, 1, false );
	if ( err != PICO_OK ) {
		return err;
	}

	pio_sm_config c = canbus_clock_program_get_default_config( offset );

	sm_config_set_jmp_pin(&c,rx_pin);

	sm_config_set_clkdiv(&c, CLK_SYS_HZ / ( freq * CYCLE ));

	return pio_sm_init(pio,CANBUS_CLOCK_SM,offset,&c);
}


static inline int canbus_rx_program_init(PIO pio, uint offset,uint rx_pin, float freq) {
	pio_sm_claim( pio, CANBUS_RX_SM );

	pio_gpio_init( pio, rx_pin );
	int err = pio_sm_set_consecutive_pindirs( pio, CANBUS_RX_SM ,rx_pin, 1, false );
	if ( err != PICO_OK ) {
		return err;
	}


	pio_sm_config config = pio_get_default_sm_config();
	sm_config_set_wrap(&rx_config,
	                   address + canbus_rx_and_ack_wrap_target,
	                   address + canbus_rx_and_ack_offset_rx_only_end);


	sm_config_set_in_pins(&config,rx_pin);
	sm_config_set_in_pin_count(&config,32);
	// left shift autopush 10
    sm_config_set_in_shift(&config, false, true, 10);


	sm_config_set_clkdiv(&config, CLK_SYS_HZ / ( freq * CYCLE ));

	return pio_sm_init(pio,
	                   CANBUS_RX_SM,
	                   offset + canbus_rx_and_ack_wrap_target,
	                   &config);
}

static inline void canbus_ack_program_reset_counters(PIO pio) {
	pio->sm[CANBUS_ACK_SM].instr = 0xe040; // set y, 0
	pio->sm[CANBUS_ACK_SM].instr = 0xe021; // set x, 1
}


static inline void canbus_ack_program_restart(PIO pio) {
	pio->ctrl |= 1u << (PIO_CTRL_SM_RESTART_LSB + CANBUS_ACK_SM);
	pio->sm[CANBUS_ACK_SM].instr = 0x0000 | canbus_rx_and_ack_program.origin;
}

static inline int canbus_ack_program_init(PIO pio, uint offset,uint rx_pin, uint tx_pin, float freq) {
	pio_sm_claim( pio, CANBUS_ACK_SM );

	pio_gpio_init( pio, rx_pin );
	pio_gpio_init( pio, tx_pin );

	int err = pio_sm_set_consecutive_pindirs( pio, CANBUS_ACK_SM ,rx_pin, 1, false );
	if ( err != PICO_OK ) {
		return err;
	}

	err = pio_sm_set_consecutive_pindirs( pio, CANBUS_ACK_SM ,tx_pin, 1, true );
	if ( err != PICO_OK ) {
		return err;
	}


	pio_sm_config config = canbus_rx_and_ack_program_get_default_config(offset);

	sm_config_set_clkdiv(&config, CLK_SYS_HZ / ( freq * CYCLE ));


	sm_config_set_in_pins(&config,rx_pin);
	sm_config_set_out_pins(&config,tx_pin);

	err = pio_sm_init(pio,
	                  CANBUS_ACK_SM,
	                  offset,
	                  &config);

	canbus_ack_program_reset_counter(pio);
	return err;
}


static inline void canbus_tx_program_reset(PIO pio) {
	pio->ctrl |= 1u << (PIO_CTRL_SM_RESTART_LSB + CANBUS_TX_SM) ;
	pio->sm[CANBUS_TX_SM].instr = 0x0000 | canbus_tx_program.origin;
}

static inline int canbus_tx_program_init(PIO pio, uint offset, uint rx_pin, uint tx_pin, float freq) {
	pio_sm_claim( pio, CANBUS_TX_SM );

	pio_gpio_init( pio, rx_pin );
	pio_gpio_init( pio, tx_pin );

	int err = pio_sm_set_consecutive_pindirs( pio, CANBUS_TX_SM ,rx_pin, 1, false );
	if ( err != PICO_OK ) {
		return err;
	}

	err = pio_sm_set_consecutive_pindirs( pio, CANBUS_TX_SM ,tx_pin, 1, true );
	if ( err != PICO_OK ) {
		return err;
	}


	pio_sm_config config = canbus_tx_program_get_default_sm_config();
	sm_config_set_wrap(&config,
	                   address + canbus_rx_and_ack_wrap_target,
	                   address + canbus_rx_and_ack_offset_rx_only_end);

	sm_config_set_jmp_pin(&config,rx_pin);
	sm_config_set_out_pins(&config,tx_pin);


	sm_config_set_clkdiv(&config, CLK_SYS_HZ / ( freq * CYCLE ));

	return pio_sm_init(pio,
	                   CANBUS_TX_SM,
	                   offset,
	                   &config);

}

#define wrap_ensure_disabled(pio,sm,func) do { \
		bool enabled = (pio->ctrl & (1u << sm)) != 0x0000; \
		pio->ctrl &= ~(1u << sm); \
		func; \
		if ( enabled ) { pio->ctrl |= (1u << sm); }\
	}while(0)

static inline int canbus_init(PIO pio, uint rx_pin, uint tx_pin, float freq) {
	int address = pio_add_program(pio,&canbus_clock_program);
	if ( address < 0 ) {
		return address;
	}
	int err = canbus_clock_program_init(pio,&address,rx_pin,freq);
	if ( err != PICO_OK ) {
		return err;
	}
	address = pio_add_program(pio,&canbus_rx_and_ack_program);
	if ( address < 0 ) {
		return address;
	}
	err = canbus_rx_program_init(pio,address,rx_pin,freq);
	if ( err != PICO_OK ) {
		return err;
	}

	err = canbus_ack_program_init(pio, address, rx_pin, tx_pin,freq);
	if ( err != PICO_OK ) {
		return err;
	}

	err = canbus_tx_program_init(pio,address, rx_pin, tx_pin, freq);
	if ( err != PICO_OK ) {
		return err;
	}

	// reset all clock so we can wait on the same IRQ.
	pio_clkdiv_restart_sm_mask(pio,0x000f);
}

%}
